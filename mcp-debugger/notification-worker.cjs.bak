#!/usr/bin/env node
/**
 * ì•Œë¦¼ ì›Œì»¤
 * 10ì´ˆë§ˆë‹¤ MySQL bugs í…Œì´ë¸”ì„ í™•ì¸í•˜ê³  ì•Œë¦¼
 * + Next.js ë¹Œë“œ ì—ëŸ¬ ê°ì§€ (server.log ëª¨ë‹ˆí„°ë§)
 */

const mysql = require('mysql2/promise');
const fs = require('fs');
const path = require('path');

const dbConfig = {
  host: process.env.DB_HOST || 'localhost',
  user: process.env.DB_USER || 'root',
  password: process.env.DB_PASSWORD || 'trend2024',
  database: process.env.DB_NAME || 'trend_video'
};

// ì„œë²„ ë¡œê·¸ ê²½ë¡œ
const SERVER_LOG_PATH = path.join(__dirname, '..', 'trend-video-frontend', 'logs', 'server.log');

// ë¹Œë“œ ì—ëŸ¬ íŒ¨í„´ (Next.js/Webpack ë¹Œë“œ ê´€ë ¨ë§Œ)
const BUILD_ERROR_PATTERNS = [
  /Export .+ doesn't exist in target module/,
  /Module not found.*\.tsx?/,
  /Cannot find module.*\.tsx?/,
  /â¨¯.*Build Error/i,
  /â¨¯.*Compile Error/i,
  /Failed to compile/i,
  /error TS\d+:/i,  // TypeScript errors
  /Unhandled Runtime Error/,
  /Module build failed/,
];

// ë§ˆì§€ë§‰ìœ¼ë¡œ ì²˜ë¦¬í•œ ë¡œê·¸ ìœ„ì¹˜
let lastLogPosition = 0;
// ìµœê·¼ ê°ì§€ëœ ì—ëŸ¬ í•´ì‹œ (ì¤‘ë³µ ë°©ì§€)
const recentErrors = new Set();

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

async function getBugs() {
  let connection;
  try {
    connection = await mysql.createConnection(dbConfig);
    const [rows] = await connection.execute(`
      SELECT id, title, summary, status, log_path, screenshot_path,
             created_at, updated_at, assigned_to, metadata
      FROM bugs
      WHERE status != 'resolved' AND status != 'closed'
      ORDER BY created_at DESC
      LIMIT 20
    `);
    return rows;
  } catch (error) {
    throw error;
  } finally {
    if (connection) {
      await connection.end();
    }
  }
}

// ë‹¤ìŒ ë²„ê·¸ ID ê°€ì ¸ì˜¤ê¸° (bug_sequence í…Œì´ë¸” ì‚¬ìš© - race condition ë°©ì§€)
async function getNextBugId() {
  let connection;
  try {
    connection = await mysql.createConnection(dbConfig);

    // bug_sequenceì—ì„œ ë‹¤ìŒ ë²ˆí˜¸ ìƒì„± (ì›ìì  ì—°ì‚°)
    await connection.execute(`UPDATE bug_sequence SET next_number = next_number + 1 WHERE id = 1`);
    const [rows] = await connection.execute(`SELECT next_number FROM bug_sequence WHERE id = 1`);

    const nextNum = rows?.[0]?.next_number;
    if (!nextNum) {
      // fallback: ê¸°ì¡´ ë°©ì‹
      const [bugRows] = await connection.execute(
        "SELECT id FROM bugs WHERE id LIKE 'BTS-%' ORDER BY id DESC LIMIT 1"
      );
      if (bugRows.length > 0) {
        const lastNum = parseInt(bugRows[0].id.replace('BTS-', ''));
        return `BTS-${String(lastNum + 1).padStart(7, '0')}`;
      }
      return 'BTS-0000001';
    }

    return `BTS-${String(nextNum).padStart(7, '0')}`;
  } finally {
    if (connection) {
      await connection.end();
    }
  }
}

// ë¹Œë“œ ì—ëŸ¬ë¥¼ ë²„ê·¸ë¡œ ë“±ë¡
async function registerBuildError(errorMessage, errorContext) {
  // ë„ˆë¬´ ì§§ê±°ë‚˜ ëª¨í˜¸í•œ ì—ëŸ¬ ë©”ì‹œì§€ í•„í„°ë§
  const trimmedMessage = errorMessage.trim();
  if (!trimmedMessage || trimmedMessage.length < 10) {
    return null;
  }

  // ë¬´ì‹œí•  íŒ¨í„´ë“¤
  const ignorePhrases = [
    'Unknown Error',
    'Error occurred',
    'Something went wrong',
    'Unknown column',      // SQL ì»¬ëŸ¼ ì—ëŸ¬ (ë¹Œë“œì™€ ë¬´ê´€)
    'SQLite pragma',       // SQLite ê²½ê³ 
    'webpack-hmr',         // HMR 404ëŠ” ì •ìƒ
    '404 in ',             // 404 ì‘ë‹µ ë¡œê·¸
    'ECONNRESET',          // ë„¤íŠ¸ì›Œí¬ ì—°ê²° ë¦¬ì…‹
    'ETIMEDOUT',           // íƒ€ì„ì•„ì›ƒ
    'ER_NO_SUCH_TABLE',    // MySQL í…Œì´ë¸” ì—†ìŒ
    'ER_BAD_FIELD_ERROR',  // MySQL ì»¬ëŸ¼ ì—ëŸ¬
    '[ì´ë¯¸ì§€ ë³€í™˜',        // ì´ë¯¸ì§€ ë³€í™˜ ë¡œê·¸
    'ì´ë¯¸ì§€ ìƒì„±',         // ì´ë¯¸ì§€ ìƒì„± ë¡œê·¸
    'scene_',              // ì”¬ ì²˜ë¦¬ ë¡œê·¸
    'Python subprocess',   // Python ì„œë¸Œí”„ë¡œì„¸ìŠ¤ ë¡œê·¸
    '- INFO -',            // Python INFO ë¡œê·¸
    '- ERROR -',           // Python ERROR ë¡œê·¸ (ë¹Œë“œ ì—ëŸ¬ ì•„ë‹˜)
    '- WARNING -',         // Python WARNING ë¡œê·¸
    'GET /',               // HTTP GET ìš”ì²­
    'POST /',              // HTTP POST ìš”ì²­
    '200 in',              // 200 ì‘ë‹µ
    '304 in',              // 304 ì‘ë‹µ
    '500 in',              // 500 ì‘ë‹µ (API ì—ëŸ¬, ë¹Œë“œ ì—ëŸ¬ ì•„ë‹˜)
    'ë”¥ë§í¬ ì˜¤ë¥˜',         // ë”¥ë§í¬ ìƒì„± ì‹¤íŒ¨ ì‹œ ìŠ¤í‚µ (ì •ìƒ ë™ì‘)
    'ì´ë²ˆ ì‹¤í–‰ ìŠ¤í‚µ',      // ì‹¤í–‰ ìŠ¤í‚µì€ ì •ìƒ ë™ì‘
    'ìƒí’ˆ ì œëª© ìƒì„± ì‹¤íŒ¨', // ìƒí’ˆ ì¹´í…Œê³ ë¦¬ ìŠ¤í‚µ (ì •ìƒ ë™ì‘)
  ];
  for (const phrase of ignorePhrases) {
    if (trimmedMessage.includes(phrase)) {
      return null;
    }
  }

  // ì»¨í…ìŠ¤íŠ¸ì—ì„œë„ ì²´í¬
  if (errorContext) {
    for (const phrase of ignorePhrases) {
      if (errorContext.includes(phrase)) {
        return null;
      }
    }
  }

  // ì—ëŸ¬ í•´ì‹œ ìƒì„± (ì „ì²´ ë©”ì‹œì§€ + ì»¨í…ìŠ¤íŠ¸ ì¼ë¶€)
  const hashSource = trimmedMessage + (errorContext || '').substring(0, 200);
  const errorHash = Buffer.from(hashSource).toString('base64').substring(0, 64);

  if (recentErrors.has(errorHash)) {
    return null; // ì´ë¯¸ ë“±ë¡ëœ ì—ëŸ¬
  }

  let connection;
  try {
    connection = await mysql.createConnection(dbConfig);

    // DBì—ì„œ ë™ì¼ ì œëª©ì˜ ìµœê·¼ ë²„ê·¸ ì²´í¬ (24ì‹œê°„ ë‚´)
    const [existingBugs] = await connection.execute(
      `SELECT id FROM bugs
       WHERE title LIKE ?
       AND created_at > DATE_SUB(NOW(), INTERVAL 24 HOUR)
       LIMIT 1`,
      [`%${trimmedMessage.substring(0, 50)}%`]
    );

    if (existingBugs.length > 0) {
      // ì´ë¯¸ ë“±ë¡ëœ ìœ ì‚¬í•œ ë²„ê·¸ê°€ ìˆìŒ
      recentErrors.add(errorHash);
      return null;
    }

    const bugId = await getNextBugId();

    // ì—ëŸ¬ íƒ€ì… ì¶”ì¶œ
    let errorType = 'Build Error';
    if (errorMessage.includes('Export') && errorMessage.includes("doesn't exist")) {
      errorType = 'Export Not Found';
    } else if (errorMessage.includes('Module not found') || errorMessage.includes('Cannot find module')) {
      errorType = 'Module Not Found';
    } else if (errorMessage.includes('SyntaxError')) {
      errorType = 'Syntax Error';
    } else if (errorMessage.includes('TypeError')) {
      errorType = 'Type Error';
    } else if (errorMessage.includes('error TS')) {
      errorType = 'TypeScript Error';
    }

    const title = `[ë¹Œë“œì—ëŸ¬] ${errorType}: ${errorMessage.substring(0, 60)}...`;
    const summary = errorMessage.substring(0, 200);

    const metadata = JSON.stringify({
      source: 'build-monitor',
      category: 'build-error',
      priority: 'P1',
      severity: 'HIGH',
      error_type: errorType,
      full_error: errorMessage,
      context: errorContext,
      detected_at: new Date().toISOString()
    });

    await connection.execute(
      `INSERT INTO bugs (id, title, summary, status, metadata, created_at, updated_at)
       VALUES (?, ?, ?, 'open', ?, NOW(), NOW())`,
      [bugId, title, summary, metadata]
    );

    // ìµœê·¼ ì—ëŸ¬ì— ì¶”ê°€ (1ì‹œê°„ í›„ ë§Œë£Œ)
    recentErrors.add(errorHash);
    setTimeout(() => recentErrors.delete(errorHash), 3600000);

    return bugId;
  } catch (error) {
    console.error('ë¹Œë“œ ì—ëŸ¬ ë“±ë¡ ì‹¤íŒ¨:', error.message);
    return null;
  } finally {
    if (connection) {
      await connection.end();
    }
  }
}

// ì„œë²„ ë¡œê·¸ì—ì„œ ë¹Œë“œ ì—ëŸ¬ ê°ì§€
async function checkBuildErrors() {
  try {
    if (!fs.existsSync(SERVER_LOG_PATH)) {
      return [];
    }

    const stats = fs.statSync(SERVER_LOG_PATH);

    // ì´ˆê¸°í™” ì‹œ íŒŒì¼ ëì—ì„œ ì‹œì‘ (ê¸°ì¡´ ì—ëŸ¬ ë¬´ì‹œ)
    if (lastLogPosition === 0) {
      lastLogPosition = stats.size;
      return [];
    }

    // íŒŒì¼ì´ truncatedë˜ì—ˆìœ¼ë©´ ì²˜ìŒë¶€í„°
    if (stats.size < lastLogPosition) {
      lastLogPosition = 0;
    }

    // ìƒˆë¡œìš´ ë‚´ìš© ì½ê¸°
    const fd = fs.openSync(SERVER_LOG_PATH, 'r');
    const bufferSize = stats.size - lastLogPosition;

    if (bufferSize <= 0) {
      fs.closeSync(fd);
      return [];
    }

    const buffer = Buffer.alloc(bufferSize);
    fs.readSync(fd, buffer, 0, bufferSize, lastLogPosition);
    fs.closeSync(fd);

    lastLogPosition = stats.size;

    const newContent = buffer.toString('utf-8');
    const lines = newContent.split('\n');

    const errors = [];
    let contextLines = [];

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];

      // ë¹Œë“œ ì—ëŸ¬ íŒ¨í„´ í™•ì¸
      for (const pattern of BUILD_ERROR_PATTERNS) {
        if (pattern.test(line)) {
          // ì»¨í…ìŠ¤íŠ¸ ìˆ˜ì§‘ (ì•ë’¤ 5ì¤„)
          const start = Math.max(0, i - 5);
          const end = Math.min(lines.length, i + 5);
          const context = lines.slice(start, end).join('\n');

          errors.push({
            message: line.replace(/^\[\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}\]\s*/, '').trim(),
            context: context
          });
          break;
        }
      }
    }

    return errors;
  } catch (error) {
    // ë¡œê·¸ ì½ê¸° ì‹¤íŒ¨ëŠ” ë¬´ì‹œ
    return [];
  }
}

async function notificationWorker() {
  console.log('');
  console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
  console.log('â•‘           ğŸ”” ë²„ê·¸ ì•Œë¦¼ ì›Œì»¤ (10ì´ˆë§ˆë‹¤ ì²´í¬)                  â•‘');
  console.log('â•‘           DB: MySQL trend_video.bugs                         â•‘');
  console.log('â•‘           + Next.js ë¹Œë“œ ì—ëŸ¬ ìë™ ê°ì§€                      â•‘');
  console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  console.log('');
  console.log('  Ctrl+Cë¡œ ì¢…ë£Œ');
  console.log('');
  console.log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
  console.log('');

  let lastBugCount = 0;

  while (true) {
    try {
      // 1. ë¹Œë“œ ì—ëŸ¬ ê°ì§€ ë° ìë™ ë“±ë¡
      const buildErrors = await checkBuildErrors();
      for (const error of buildErrors) {
        const bugId = await registerBuildError(error.message, error.context);
        if (bugId) {
          console.log(`\n[${new Date().toLocaleTimeString()}] ğŸ”§ ë¹Œë“œ ì—ëŸ¬ ê°ì§€ â†’ ${bugId} ë“±ë¡`);
          console.log(`   ğŸ“ ${error.message.substring(0, 70)}...`);
        }
      }

      // 2. DB ë²„ê·¸ ëª©ë¡ í™•ì¸
      const bugs = await getBugs();
      const currentCount = bugs.length;

      if (currentCount > 0) {
        // ê°œìˆ˜ê°€ ë³€ê²½ë˜ì—ˆê±°ë‚˜, ë²„ê·¸ê°€ ìˆìœ¼ë©´ ì•Œë¦¼
        if (currentCount !== lastBugCount) {
          console.log(`\n[${new Date().toLocaleTimeString()}] ğŸš¨ ë¯¸í•´ê²° ë²„ê·¸: ${currentCount}ê±´`);
          console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');

          bugs.slice(0, 5).forEach((bug) => {
            const statusIcon = bug.status === 'open' ? 'ğŸ”´' :
                             bug.status === 'in-progress' ? 'ğŸŸ¡' : 'âšª';

            console.log(`${statusIcon} ${bug.id}`);
            console.log(`   ğŸ“ ${bug.title}`);
            if (bug.summary) {
              console.log(`   ğŸ’¬ ${bug.summary.substring(0, 80)}...`);
            }
            if (bug.log_path) {
              console.log(`   ğŸ“„ ${bug.log_path}`);
            }
            if (bug.screenshot_path) {
              console.log(`   ğŸ“¸ ${bug.screenshot_path}`);
            }
            if (bug.assigned_to) {
              console.log(`   ğŸ‘¤ ë‹´ë‹¹: ${bug.assigned_to}`);
            }
            console.log('');
          });

          if (currentCount > 5) {
            console.log(`   ... ì™¸ ${currentCount - 5}ê±´ ë” ìˆìŒ`);
            console.log('');
          }

          console.log('ğŸ’¡ í™•ì¸: http://localhost:2000/admin/bugs');
          console.log('');
        } else {
          // ê°œìˆ˜ê°€ ê°™ìœ¼ë©´ ì¡°ìš©íˆ ëŒ€ê¸°
          process.stdout.write(`\r[${new Date().toLocaleTimeString()}] ğŸ”„ ëª¨ë‹ˆí„°ë§ ì¤‘... (${currentCount}ê±´ ëŒ€ê¸°)`);
        }
      } else {
        if (lastBugCount > 0) {
          console.log(`\n[${new Date().toLocaleTimeString()}] âœ… ëª¨ë“  ë²„ê·¸ ì²˜ë¦¬ ì™„ë£Œ!`);
        } else {
          process.stdout.write(`\r[${new Date().toLocaleTimeString()}] âœ… ëŒ€ê¸° ì¤‘ (ë²„ê·¸ ì—†ìŒ)`);
        }
      }

      lastBugCount = currentCount;

    } catch (error) {
      console.error(`\n[${new Date().toLocaleTimeString()}] âŒ DB ì¡°íšŒ ì‹¤íŒ¨:`, error.message);
    }

    // 10ì´ˆ ëŒ€ê¸°
    await sleep(10000);
  }
}

notificationWorker().catch(console.error);
